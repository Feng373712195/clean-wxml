<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        
        const str = `<template name="car-model-list">
                        <view wx:if="{{ type =='chat' }}" class="car-model-list">
                            <navigator
                                hover-class="hoverClass"
                                url="/pages/chat/chat?id={{item.id}}"
                                data-id="{{ item.style_id ? item.style_id: item.object_id }}"
                                data-order="{{ item.id }}"
                                wx:key="{{index}}"
                                class="list-block item-border-bottom"
                                wx:for="{{carModellist.list}}">
                                <image lazy-load="true" mode="aspectFit" src="{{item.thumb}}" style="width: 120px; height: 80px;" />
                                <view class="car-info">
                                    <text class="name">{{item.name}}</text>
                                    <template is="star" data="{{ starData: item.starData }}" ></template>
                                    <text class="price">{{item.price}}</text>
                                </view>
                                <text data-styleid="{{item.style_id}}" data-index="{{index}}" wx:if="{{carModellist.showbtn}}" catchtap="aTapAskprice" class="{{item.status ? 'tag tag-askprice': 'tag tag-askprice-disable' }}">一键询价</text>
                                <button plain="{{true}}" class="right-btn" hover-class="right-btn-hover" wx:if="{{item.rightText}}"
                                    size="default"
                                    catchtap="{{carModellist.rightBtnTapName}}"
                                    data-id="{{item.id}}">{{item.rightText}}</button>
                            </navigator>
                        </view>
                        <view wx:if="{{ type=='carlist' }}" class="car-model-list">
                            <view bindtap="toDetail"
                                data-id="{{ item.style_id ? item.style_id: item.object_id }}"
                                data-order="{{ item.id }}"
                                data-type="{{ item.type ? item.type : '' }}"
                                  data-thumb="{{item.thumb}}"
                                  data-name="{{item.name}}"
                                wx:key="{{index}}"
                                class="list-block item-border-bottom"
                                wx:for="{{carModellist.list}}"
                                hover-class="hoverClass">
                                <image mode="aspectFit" src="{{item.thumb}}" style="width: 120px; height: 80px;" />
                                <view class="car-info">
                                    <view class="info-top">
                                        <text class="name {{ item.type == 'article' ? 'newsName' : '' }}">{{item.name}}</text>
                                        <view class="title-tag" wx:if="{{ item.tag != underfined && item.tag != '' }}">{{ item.tag }}</view>
                                    </view>
                                    <template is="star" data="{{ starData: item.starData }}" wx:if="{{ item.tag == '' && item.type != 'article' }}"></template>
                                    <text class="price {{ item.tag != '' ? 'priceMagin' : '' }} ">{{item.price}}</text>
                                    <view class="list-date" wx:if="{{ item.tag != '' && item.date != '' }}"> {{ item.date }} </view>
                                </view>
                                <text data-id="{{item.id}}" data-styleid="{{item.style_id}}" data-index="{{index}}" wx:if="{{carModellist.showbtn}}" catchtap="aTapAskprice" class="{{item.status ? 'tag tag-askprice': 'tag tag-askprice-disable' }}">{{carModellist.inquiry? '免费询价' : '一键询价'}}</text>
                                <button plain="{{true}}" class="right-btn" hover-class="right-btn-hover" wx:if="{{item.rightText}}"
                                    size="default"
                                    catchtap="{{carModellist.rightBtnTapName}}"
                                    data-id="{{item.id}}"
                                    data-index="{{index}}">{{item.rightText}}</button>
                                    <view class="icon-right" wx:if="{{!item.rightText && !carModellist.showbtn}}"></view>
                            </view>
                        </view>
                        <!-- 口碑排行 -->
                        <view wx:if="{{type=='praise'}}" class="car-model-list">
                            <view
                                bindtap="toDetail"
                                wx:key="{{index}}"
                                data-id="{{item.model_id}}"
                                class="list-block item-border-bottom"
                                wx:if="{{index<3}}"
                                wx:for="{{koubeiList}}"
                                hover-class="hoverClass">
                                <image mode="aspectFit" src="{{item.thumb}}" style="width: 120px; height: 80px;" />
                                <view class="car-info">
                                   <text class="name">{{item.name}}</text>
                                   <template is="star" data="{{ starData: item.starData }}" ></template>
                                   <text class="price">{{item.price}}</text>
                                   <view class="six_box_warpper">
                                        <view class="six_box six_box_{{index}}"><text>{{index+1}}</text></view>
                                   </view>

                                </view>
                            </view>
                            <view
                                hover-class="hoverClass"
                                bindtap="toDetail"
                                wx:key="{{index}}"
                                data-id="{{item.model_id}}"
                                class="list-block item-border-bottom"
                                wx:if="{{index>=3 && index<5}}"
                                wx:for="{{koubeiList}}">
                                <view class="car-info_simple">
                                   <text class="name">{{item.name}}</text>
                                   <view class="six_box_warpper">
                                        <view class="six_box"><text>{{index+1}}</text></view>
                                   </view>
                                </view>
                            </view>
                        </view>

                        <view wx:if="{{ type=='carmouth' }}" class="car-model-list" wx:for="{{carModellist}}" wx:key="{{index}}">
                            <navigator url="/pages/detail/detail?id={{item.model_id}}" data-modelname="{{item.model_name}}" data-modelid="{{item.model_id}}" bindtap="catchHistory">
                                <view class="list-block {{index+1==lengths?'':'item-border-bottom'}}" >
                                    <view style="position:relative">
                                        <view class="car-ranking">{{index+1}}</view>
                                        <image mode="aspectFit" src="{{item.thumb}}"  />
                                    </view>
                                    <view class="car-wordofmouth">
                                        <view class="car-name">
                                            <view class="">{{item.model_name}}</view>
                                            <view class="">{{item.minprice}}万-{{item.maxprice}}万</view>
                                        </view>
                                        <view class="car-score" data-modelname="{{item.model_name}}" data-modelid="{{item.model_id}}" catchtap="jumpToCarerRating">
                                            <view>{{item.score}}</view>
                                            <view>{{item.koubei_count}}条口碑</view>
                                        </view>
                                    </view>
                                </view>
                            </navigator>
                        </view>
                    </template>`

        // 取得表情的属性
        const getAttr = (tag,attr) => {
            const hasAttr = tag.indexOf(` ${attr}`)
            if( hasAttr ){
                const attrStrStartL = hasAttr + ` ${attr}=`.length;
                // 获取属性在标签的开始位置
                const startMark = tag.substr( attrStrStartL,  1);
                // 获取属性在标签的结束位置
                const endIndex = tag.substring( attrStrStartL + 1 , ).indexOf(startMark);
                //取得整段属性
                const AttrStr = tag.substring( attrStrStartL + 1 , attrStrStartL + endIndex + 1 )
                return AttrStr
            }else{
                return ''
            }
        }

        // 把Wxml字符串转为树结构
        // 在转成树结构的过程中就可以把所有节点存储起来
        // 标签不会被覆盖 这个核实过了

        // 2019-03-21 
        // selectNodeCache不再作为全局变量 而作为getWxmlTree的返回值
        
        // 2019-03-25
        //  getTemplateWxmlTree 修改
        //  返回结构如
        //  templates:{
        //     'template-a':{
        //         template:,
        //         selectNodes:''
        //     },
        //     'template-b':{
        //         template:,
        //         selectNodes:''
        //     }
        // }
        // 注意嵌套template selectNode返回 

        const getWxmlTree =  (wxmlStr,isTemplateWxml = false)=>{

                const templateStartTagReg = /\<template.*\s+name=/

                const useTemplateTagReg = /<\template.*\s+is=/
                
                // 对已经查找过的节点位置缓存 下次可以直接在这里获取
                const selectNodeCache = {}

                // template层数
                let templateCount = 0;

                // 临时遍历1
                let _todoName1 = {}

                //存放找到的模版
                const findTemplates = {}
                // 模版缓存
                const templateCache = {}
                // 找到的使用模版 反正重名 使用数组
                const findUseTemplates = []

                // 过滤调pageWxml中的注释 
                // 注意 单行注释可以 去除多行注释不成功
                wxmlStr = wxmlStr.replace(/\<!--([\s\S]*?)-->/g,'')

                //Wxml树结构
                const WxmlTree = {
                    root:{
                        childs:[

                        ],
                        parent:{
                            key:null,
                            obj:null,
                        }
                    }
                };
            
                let head = WxmlTree.root;
                let parentkey = 'root';
                
                // 取得标签内的Class
                // 注意还有hover-class 之类的情况
                const _getTagClass = (tag,arr)=>{
            
                    let TagClass = arr ? arr : [];
                    
                    // 判断前面是否有空格 避免匹配到 *-class 
                    const hasClass = /\s+class=/;
                    // 判断标签是否拥有class
                    if( hasClass.test(tag) ){
                        // 获取class属性在标签的开始位置
                        const startIndex = tag.search(/class\=[\'|\"]/)
                        // 判断开始是双引号还是单引号
                        const startMark = tag.substr(startIndex+6,1);
                        // 获得结束位置
                        const endIndex = tag.substring(startIndex + 7 ,tag.length).indexOf(startMark);
                        // 取得整段class
                        let TagClassStr = tag.substring( startIndex , startIndex + endIndex + 8 );
                        
                        //获取动态选人的class
                        const dynamicClassReg = /\{\{(.*?)\}\}/
                        let dynamicClass = '';
                        while( dynamicClass = dynamicClassReg.exec(TagClassStr) ){
                            // console.log( dynamicClass,'dynamicClass' )
                            dynamicClass[1].replace(/[\'|\"](.*?)[\'|\"]/g,($1,$2)=>{
                                $2 && TagClass.push($2)
                            })
                            TagClassStr = TagClassStr.replace(dynamicClass[0],'')
                        }

                        TagClassStr.replace(/class=[\'|\"](.*)[\'|\"]/,function(classStr,classNames){
                            TagClass = TagClass.concat( classNames.split(" ").filter(v=>v) )
                        })

                        // 一些写法不规范的开发者 会写多个class 这里先不管
                        tag = tag.replace(/(class=[\'|\"].*?[\'|\"])/,'');
                        if( hasClass.test(tag) ) {
                            return _getTagClass(tag,TagClass)
                        }
                    }

                    return TagClass;
                }
                
                // 取得标签内的id
                const _getId = (tag)=>{
                    // 判断前面是否有空格 避免匹配到 *-class 
                    const hasId =  /\s+id=/;
                    if( hasId.test(tag) ){

                        // 获取id属性在标签的开始位置
                        const startIndex = tag.search(/id\=[\'|\"]/)
                        // 判断开始是双引号还是单引号
                        const startMark = tag.substr(startIndex + 3,1);
                        // 获得结束位置
                        const endIndex = tag.substring(startIndex + 4 ,tag.length).indexOf(startMark);
                        // 取得整段id
                        const TagIdStr = tag.substring( startIndex , startIndex + endIndex + 5 )
            
                        return TagIdStr.replace(/id=[\'|\"](.*)[\'|\"]/,'$1');
                    }

                    return "";
                }
                
                // 取得标签名称
                const _getTagName = (tag)=>{
                    const tagExec = /\<([\w|\-]+)\s?|\/([\w|\-]+)\s?\>/.exec(tag)
                    const tagName = tagExec[1] ? tagExec[1] : tagExec[2];
                    return tagName
                }

                // 存入节点缓存对象 
                const _setNodeCache = (tag,classes,id)=>{
                    //避免用重复class元素
                    if( classes ){
                        classes.forEach(classname=>{
                            if(!selectNodeCache[`.${classname}`]){
                                selectNodeCache[`.${classname}`] = [];
                            }
                            selectNodeCache[`.${classname}`].push(tag);
                        })
                    }
                    //避免有重复id元素
                    if( id ){
                        if(!selectNodeCache[`#${id}`]){
                            selectNodeCache[`#${id}`] = [];
                        }
                        selectNodeCache[`#${id}`].push(tag);
                    }
                }
                
                // 合并两个selectNode
                // 把nodes2合并入nodes1 最终返回nodes1
                const mergeSelectNode = (nodes1,nodes2)=>{
                    const node2Keys = Object.keys(nodes2)
                    node2Keys.forEach(key=>{
                        if(nodes1[key]){
                            nodes1[key] = nodes1[key].concat(nodes2[key])
                        }else{
                            nodes1[key] = nodes2[key]
                        }
                    })
                    return nodes1
                }
                                
                const isSingeTagReg = /\<(.*)\/\>/;
                const isCloseTagReg = /\<\/(.*)\>/;
                const isCompleteTagReg = /\<.*\>.*\<.*\>/

                // 是否import标签
                const isImportReg = /import/i; 
                // 是否template标签
                const isTemplateReg = /template/i;
                
                return new Promise( async (resolve,reject)=>{
                    // 从上到下获取全部标签    
                    // 注意标签连写情况 如：<view>A</view><view>B</view><view>C</view>
                    let match = null

                    while( match = /\<[\s\S]*?\>/.exec(wxmlStr) ){

                        let $1 = match[0]
                        wxmlStr = wxmlStr.replace($1,'');

                        const tagClass = _getTagClass($1);
                        const tagId = _getId($1);
                        const tagName = _getTagName($1);

                        if( isImportReg.test(tagName) ){
                            const importSrc =  getAttr($1,'src');

                            findTemplates[importSrc] =  () => new Promise( async (_resolve,_reject)=>{
                                let templatePath = '';
                                
                                // 查找模版规则 首先查找相对路径 如果相对路径没有 则尝试绝对路径 如果都没有则弹出错误 当时不印象继续往下执行
                                templatePath = path.join( path.join( PAGES_PATH,PAGE_DIR_PATH ), importSrc );
                                fsp.readFile(templatePath,'utf-8')
                                .catch(err=>{
                                    templatePath = path.join( WX_DIR_PATH,importSrc )
                                    return fsp.readFile(templatePath,'utf-8')
                                })
                                .catch(err=>{
                                    console.log('没有找到模版文件 模版地址:',importSrc);
                                    reject()
                                })
                                .then(tmp =>{
                                    return getTemplateWxmlTree(importSrc,tmp)
                                })
                                .then(res =>{
                                    console.log( 'resolve ===========' )
                                    _resolve(res)
                                })
                                .catch(err=>{
                                    console.log('getTemplateWxmlTree执行时遇到错误')
                                    console.log(err)
                                    reject()
                                })

                            })
                        }

                        if( isTemplateWxml && isTemplateReg.test(tagName) ){
                            console.log($1,'isTemplateReg')
                           if( templateStartTagReg.test($1) ){
                                ++templateCount
                               console.log('templateCount',templateCount)
                                _todoName1[getAttr($1,'name')] = {}
                                continue;
                           }else if( isCloseTagReg.test($1) ){
                               --templateCount
                               console.log('templateCount',templateCount)
                               if( templateCount == 0 ){
                                    console.log('last close')
                                    console.log('templateCount',templateCount)
                                    continue;
                               }
                           }else if( isCompleteTagReg.test($1) ){

                           }else{
                               ++templateCount
                               console.log('templateCount',templateCount)
                           }
                        }

                        //是否单标签
                        if( isSingeTagReg.test($1) ){
                            // console.log('是单标签')

                            const self = {
                                [$1]:{
                                    childs:[],
                                    class:tagClass,
                                    id:tagId,
                                    tag:tagName,
                                    statrTag:true,
                                    endTag:true,
                                    parent:{
                                        key:parentkey,
                                        obj:head    
                                    }
                                }
                            }

                            //收集使用的模版
                            if( isTemplateReg.test(tagName) ){
                                findUseTemplates.push( { [getAttr($1,'is')] : self } )
                            }

                            _setNodeCache(self[$1],tagClass,tagId)

                            head.childs.push(self)

                            continue;
                        }
                
                        //是否闭合标签
                        if( isCloseTagReg.test($1) ){
                            // console.log('是闭合标签')

                            const isCompleteTag = isCompleteTagReg.test($1);

                            //需找到闭合标签 把指针指向上一层
                            if( !isCompleteTag ){
                                try{
                                    // console.log(head)
                                    parentkey = head.parent.key
                                    head = head.parent.obj
                                }catch(e){
                                    console.log('完毕标签 head 报错')
                                    console.log(e)
                                    return;
                                }   
                            }

                            const self = {
                                [$1]:{
                                    childs:[],
                                    class:tagClass,
                                    id:tagId,
                                    tag:tagName,
                                    statrTag:isCompleteTag ? true : false,
                                    endTag:true,
                                    parent:{
                                        key:parentkey,
                                        obj:head    
                                    }
                                }
                            }

                            if( isTemplateReg.test(tagName) ){
                                findUseTemplates.push( { [getAttr($1,'is')] : self } )
                            }

                            if( isCompleteTag ){
                                _setNodeCache(self[$1],tagClass,tagId)
                            }

                            try{
                                // console.log(head)
                                head.childs.push(self)
                            }catch(e){
                                console.log('闭合标签 head 报错')
                                console.log(e)
                                return;
                            }

                            continue;
                        }

                        // console.log('是起始标签')
                        
                        //不是闭合标签 也不是 单标签 就是启始标签
                        const self = {
                            [$1]:{
                                childs:[],
                                class:tagClass,
                                id:tagId,
                                tag:tagName,
                                statrTag:true,
                                endTag:false,
                                parent:{
                                    key:parentkey,
                                    obj:head
                                }
                            }
                        }

                        if( isTemplateReg.test(tagName) ){
                            findUseTemplates.push( { [getAttr($1,'is')] : self } )
                        }

                        _setNodeCache(self[$1],tagClass,tagId)
                        
                        try{
                            // console.log(head)
                            head.childs.push(self)
                        }catch(e){
                            console.log('启始标签 head 报错')
                            console.log(e)
                            return;
                        }

                        //把指针指向这个标签
                        head = self[$1];
                        parentkey = $1;
                
                    }
                    
                    if( !isTemplateWxml ){
                        for( const name in findTemplates ){
                            templateCache[name] = await findTemplates[name]()
                        }
                    }

                    findUseTemplates.forEach(usetml=>{
                        // 准备被替换的模版
                        let replaceTml = null;
                        const useTemplateName = Object.keys(usetml)[0];

                        for( let importTmlPath in templateCache ){
                            if( templateCache[importTmlPath][useTemplateName] ){
                                replaceTml = templateCache[importTmlPath][useTemplateName]
                                break;
                            }
                        }

                        if( replaceTml ){
                            const { templateWxmlTree,selectNode } = replaceTml
                            // 找到要被替换模版在父组件的位置
                            const useTemplateStr = Object.keys(usetml[useTemplateName])[0]
                            let templateParentTheChilren = usetml[useTemplateName][useTemplateStr].parent.obj.childs;
                            let templatehaschildrenNodeIndex = templateParentTheChilren.indexOf(usetml[useTemplateName])    
                            // 进行替换 
                            Array.prototype.splice.apply( templateParentTheChilren,[templatehaschildrenNodeIndex,1,...templateWxmlTree] )
                            // 合并 页面的selectNode 和 组件的selectNode
                            mergeSelectNode(selectNodeCache,selectNode)
                        }
                    })

                    resolve({ WxmlTree,selectNodeCache });
                })
        }

        // 把Wxml字符串转为树结构
        const getTemplateWxmlTree = async (temkey,wxmlStr) => {
            
            // const templates = {};
            // const templateStartRegExp = /\<template.*\>/
            // const templateEndRegExp = /\<\/template.*\>/
            
            // const wxmlStrFindTemplate = (str,finds) => {
            //     finds = finds || [];
            //     let templateName = ''
            //     const templateStartIndex = str.search(templateStartRegExp)
            //     const templateEndIndex = str.search(templateEndRegExp) 

            //     if( templateStartIndex!= -1 && templateEndIndex != -1 ){
            //     let tpl = str.substr(templateStartIndex,templateEndIndex + 11)
            //     str = str.replace(tpl,'')
            //     finds.push({ name:'',tpl:tpl.replace(templateStartRegExp,($1,$2)=>{
            //             templateName = getAttr($1,'name')
            //             return ''
            //     })
            //     .replace(templateEndRegExp,'') })
            //     finds[finds.length-1].name = templateName;
            //     return wxmlStrFindTemplate(str,finds)
            //     }
            //     return finds;
            // }

            // const templateStrArr = wxmlStrFindTemplate(wxmlStr)
            // for( let index = 0,len = templateStrArr.length; index < len ; index++ ){
            //     const templateName = templateStrArr[index].name
            //     console.log( templateStrArr[index].name,'<<<<<<<<<<<<<<<<<<<<< templateName >>>>>>>>>>>>>>>>>>>>>' )
            //     const { WxmlTree:templateWxmlTree,selectNodesCache } = await getWxmlTree(templateStrArr[index].tpl,true)
            //     templates[templateName] = {
            //         templateWxmlTree:templateWxmlTree.root.childs,
            //         templateSelectNodes:selectNodesCache
            //     }
            // }

            // return templates

            return await getWxmlTree(wxmlStr,true)
            
        }

        const startWork = async (pageWxml)=>{
            // const { WxmlTree,selectNodeCache } = await getWxmlTree(pageWxml);
            const { templateWxmlTree,templateSelectNodes } = getTemplateWxmlTree('test',pageWxml)
        }

        startWork(str)

    </script>
</body>
</html>